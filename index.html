<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Coffee Mug — It's a Bug! (AR.js + Hiro)</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #hint {
      position: fixed;
      top: 10px; left: 10px; right: 10px;
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 14px;
      border-radius: 12px;
      font-size: 15px;
      text-align: center;
      z-index: 999;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <div id="hint">
    Наведи на маркер <b>Hiro</b> → кружки разлетаются и начинают жить своей жизнью<br>
    Тап по экрану — включить/выключить вращение + качание
  </div>

  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true"
    arjs="sourceType: webcam; debugUIEnabled: false; trackingMethod: best">

    <a-assets timeout="60000">
      <a-asset-item id="mugModel" src="Coffe-Mug.glb"></a-asset-item>
    </a-assets>

    <a-marker preset="hiro">
      <a-entity id="mugRoot" position="0 0 0"></a-entity>
    </a-marker>

    <!-- УЛУЧШЕННАЯ КАМЕРА: подальше + под углом сверху -->
    <a-entity camera
              position="0 0.8 2.2"
              rotation="-18 0 0">
    </a-entity>
  </a-scene>

  <script>
    (function(){
      const marker = document.querySelector('a-marker');
      const mugRoot = document.querySelector('#mugRoot');

      const modelEl = document.createElement('a-entity');
      modelEl.setAttribute('gltf-model', '#mugModel');
      modelEl.setAttribute('scale', '0.6 0.6 0.6');
      mugRoot.appendChild(modelEl);

      let parts = [];
      let animFrame = null;
      let rotating = false;
      let rotateAngleY = 0;
      let rotateAngleX = 0; // новое — качание по X

      function easeOutCubic(t) {
        t = Math.min(1, Math.max(0, t));
        return 1 - Math.pow(1 - t, 3);
      }

      modelEl.addEventListener('model-loaded', () => {
        const obj = modelEl.getObject3D('mesh');
        if (!obj) return console.warn('Модель не загрузилась');

        parts = [];
        obj.traverse(node => {
          if (node.isMesh) {
            parts.push(node);
            node.userData.origPos = node.position.clone();
            node.userData.collapsedPos = new THREE.Vector3(0, 0.02, 0);

            const angle = (parts.length - 1) / 3 * Math.PI * 2;
            const radius = 0.1;
            node.userData.targetPos = new THREE.Vector3(
              Math.cos(angle) * radius,
              0.02,
              Math.sin(angle) * radius
            );
            node.position.copy(node.userData.collapsedPos);
          }
        });

        marker.addEventListener('markerFound', () => startTransition(true));
        marker.addEventListener('markerLost', () => startTransition(false));

        // Тап — включаем и выключаем анимацию вращения + качания
        mugRoot.sceneEl.addEventListener('click', () => {
          rotating = !rotating;
        });

        let animState = null;

        function startTransition(show) {
          if (parts.length === 0) return;
          const now = performance.now();
          animState = {
            start: now,
            duration: 700,
            from: parts.map(p => p.position.clone()),
            to: parts.map(p => show ? p.userData.targetPos.clone() : p.userData.collapsedPos.clone())
          };
          if (!animFrame) tick(now);
        }

        function tick(time) {
          if (rotating) {
            rotateAngleY += 0.008;
            rotateAngleX = Math.sin(performance.now() * 0.001) * 0.15; // плавное качание
            mugRoot.object3D.rotation.set(rotateAngleX, rotateAngleY, 0);
          }

          if (animState) {
            const t = (time - animState.start) / animState.duration;
            const e = easeOutCubic(t);
            parts.forEach((p, i) => {
              p.position.lerpVectors(animState.from[i], animState.to[i], e);
            });
            if (t >= 1) animState = null;
          }

          animFrame = requestAnimationFrame(tick);
        }

        animFrame = requestAnimationFrame(tick);
      });
    })();
  </script>
</body>
</html>